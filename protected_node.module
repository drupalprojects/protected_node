<?php
/*
 * @file
 * Protected node module
 */

define('PROTECTED_NODE_PER_NODE_PASSWORD', 0);
define('PROTECTED_NODE_PER_NODE_AND_GLOBAL_PASSWORD', 1);
define('PROTECTED_NODE_GLOBAL_PASSWORD', 2);

/**
 * Implementation of hook_help().
 * @link http://api.drupal.org/api/function/hook_help/6
 */
function protected_node_help($path, $arg) {
  switch ($path) {
  case 'admin/modules#description' :
    return t('With this module anybody who has edit protected node permission can password protect his or her own node.');

  }
}

/**
 * Implementation of hook_perm().
 * @link http://api.drupal.org/api/function/hook_perm/6
 */
function protected_node_perm() {
  $perms = array(
    'access protected content',
    'bypass password protection',
    'edit protected content',
  );
  foreach (array_keys(node_get_types()) as $type) {
    $perms[] = 'edit protected ' . $type;
  }

  return $perms;
}

/**
 * Implementation of hook_menu().
 * @link http://api.drupal.org/api/function/hook_menu/6
 */
function protected_node_menu() {
  module_load_include('settings.inc', 'protected_node');
  return protected_node_menu_array();
}

/**
 * Implementation of hook_init().
 * @link http://api.drupal.org/api/function/hook_init/6
 */
function protected_node_init() {
  global $user;

  // are we about to display a node?
  // can user see all nodes anyway?
  if (arg(0) != 'node' || !is_numeric(arg(1)) || user_access('bypass password protection')) {
    return;
  }

  // get the node
  $node = node_load(arg(1));

  // is the node protected?
  if (!$node->protected_node_is_protected) {
    return;
  }

  if (!$user->uid) {
    // do not cache anything for anonymous users as that could make
    // the content of the page available to people who never enter
    // the password (especially with aggressive caching.)
    if (variable_get('cache', CACHE_DISABLED)) {
      $GLOBALS['conf']['cache'] = CACHE_DISABLED;
    }
  }
  else {
    // author looking at his work?
    if ($node->uid === $user->uid) {
      return;
    }
  }

  // user cannot access any protected node
  // (this check avoids the rather useless drupal_goto() and thus does not
  // change the URL on the user.)
  if (!user_access('access protected content')) {
    drupal_access_denied();
    return;
  }

  // user already entered the password?
  if (!empty($_SESSION['_protected_node']['passwords'][$node->nid])) {
    $when = $_SESSION['_protected_node']['passwords'][$node->nid];
    if ($when > variable_get('protected_node_session_timelimit', 0) // global reset time
     && $when > $node->protected_node_passwd_changed) {  // this page reset time
      return;
    }
    // the session is out of date, we can as well get rid of it now
    unset($_SESSION['_protected_node']['passwords'][$node->nid]);
  }

  $query = drupal_get_destination();
  if (!empty($_SERVER['HTTP_REFERER'])) {
    $query .= '&back=' . urlencode($_SERVER['HTTP_REFERER']);
  }
  $query .= '&protected_nid=' . $node->nid;

  drupal_goto('protected-node', $query);
}

/**
 * Call module implemented functions with a parameter passed as reference
 * instead of copy.
 *
 * For calls that require multiple parameters, use an array or object.
 *
 * @param[in] $hook  The name of the hook to call
 * @param[in,out] $param  The one parameter to pass to the hook functions
 */
function protected_node_invoke($hook, &$param) {
  foreach (module_implements($hook) as $module) {
    call_user_func($module .'_'. $hook, $param);
  }
}

/**
 * Implementation of hook_form_alter().
 * @link http://api.drupal.org/api/function/hook_form_alter/6
 *
 * Add the protected node form widgets.
 *
 * Turn off the auto-complete feature on this form since it could otherwise
 * pre-fill the password with a wrong parameter.
 *
 * @param[in,out] $form  The form to alter
 * @param[in,out] $form_state  The current state of the form
 * @param[in] $form_id  The name of the form being modified
 */
function protected_node_form_alter(&$form, &$form_state, $form_id) {
  if (isset($form['type']['#value']) && $form['#id'] == 'node-form'
  && (user_access('edit protected content') || user_access('edit protected ' . $form['type']['#value']))) {
    module_load_include('settings.inc', 'protected_node');
    protected_node_node_form_alter($form);
  }
}

/**
 * Implementation of hook_nodeapi().
 * @link http://api.drupal.org/api/function/hook_nodeapi/6
 */
function protected_node_nodeapi(&$node, $op, $arg = 0, $page = 0) {
  global $user;
  // ugly but we want to keep some variables between the validation and insert/update
  global $_protected_node_emails;
  global $_protected_node_random_passwd;

  switch ($op) {
  case 'load':
    return protected_node_load($node->nid);

  case 'validate':
    if ($node->protected_node_is_protected) {
      $missing_password = FALSE;
      if (empty($node->protected_node_passwd)) {
        // password missing in database too?
        $sql = "SELECT protected_node_passwd FROM {protected_nodes} WHERE nid = %d";
        $result = trim(db_result(db_query($sql, $node->nid))); // getting "    " (40 spaces) when empty
        if (empty($result)) {
          $missing_password = TRUE;
        }
      }

      if ($node->protected_node_emails) {
        if ($node->status) {
          // verify each email address
          $emails = explode(',', str_replace(array("\r", "\n"), ',', $node->protected_node_emails));
          foreach ($emails as $k => $m) {
            $m = trim($m);
            if ($m) {
              if (!valid_email_address($m)) {
                form_error($arg['protected_node']['protected_node_emails'], t('Invalid email address: @m. Please correct this mistake and try again.', array('@m' => $m)));
                unset($emails[$k]); // unset just in case; should be useless though
              }
              else {
                $emails[$k] = $m;
              }
            }
            else {
              // ignore empty entries
              unset($emails[$k]);
            }
          }
          $_protected_node_emails = implode(', ', $emails);
          if ($_protected_node_emails && $missing_password && variable_get('protected_node_random_password', FALSE)) {
            // automatically generate a password for the email (note that means the author won't know the password!)
            $_protected_node_random_passwd = user_password();
            $missing_password = FALSE; // not missing anymore
            drupal_set_message('A random password was generated in order to send the email about this page. Remember that changing the password will prevent users you just emailed from accessing this page.', 'warning');
          }
        }
        else {
          // the node is not published, forget about emails!
          form_error($arg['protected_node']['protected_node_emails'], t('Invalid email address: @m. Please correct this mistake and try again.', array('@m' => $m)));
          $_protected_node_emails = '';
        }
      }

      if ($missing_password) {
        switch (variable_get('protected_node_use_global_password', PROTECTED_NODE_PER_NODE_PASSWORD)) {
        case PROTECTED_NODE_PER_NODE_PASSWORD:
          // $arg is the form in this case
          form_error($arg['protected_node']['protected_node_passwd'], t('To protect this page, please enter a password.'));
          break;

        }
      }
    }
    elseif (trim($node->protected_node_emails)) {
      form_error($arg['protected_node']['protected_node_emails'], t('No email can be sent by the protected node module when the node is not protected.'));
    }
    break;

  case 'insert':
  case 'update':
    if (isset($_protected_node_random_passwd)) {
      $node->protected_node_passwd = $_protected_node_random_passwd;
    }
    if (!empty($_protected_node_emails)) {
      $node->protected_node_emails = $_protected_node_emails;
    }
    protected_node_save($node);
    if ($node->protected_node_is_protected && $node->protected_node_emails) {
      module_load_include('mail.inc', 'protected_node');
      protected_node_send_mail($node);
    }
    break;

  case 'view':
    if ($node->protected_node_is_protected) {
      // Accessed for search indexing? (usually by cron.php)
      if ($node->build_mode == NODE_BUILD_SEARCH_INDEX) {
        // "user" could see the node, but at this time, not its contents
        // (the current user is Anonymous, so that statement is not exactly true,
        // but at the time of the search index building we cannot know who will
        // be searching so we let go without the access denied error.)
        protected_node_invoke('protected_node_hide', $node);
      }
      elseif (!user_access('bypass password protection')) {
        if (!$user->uid && variable_get('cache', 0)) {
          $GLOBALS['conf']['cache'] = FALSE;
        }

        if ($node->uid !== $user->uid) {
          // is there a password?
          if (!isset($_SESSION['_protected_node']['passwords'][$node->nid])) {
            // is password out of date?
            $when = $_SESSION['_protected_node']['passwords'][$node->nid];
            if ($when <= variable_get('protected_node_session_timelimit', 0) // global reset time
             || $when <= $node->protected_node_passwd_changed) {  // this page reset time
              unset($_SESSION['_protected_node']['passwords'][$node->nid]);
            }
          }
          if (!isset($_SESSION['_protected_node']['passwords'][$node->nid])) {
            if (!user_access('access protected content')) {
              // user will never be given access (no drupal_goto() call)
              drupal_access_denied();
            }
            // user could see the node, but at this time, not its contents
            protected_node_invoke('protected_node_hide', $node);
          }
        }
      }
    }
    break;

  case 'delete':
    db_query('DELETE FROM {protected_nodes} WHERE nid = %d', $nid);
    break;

  }
}


/**
 * Implementation of hook_protected_node_hide().
 *
 * We implement this callback since it makes sense (I think) although
 * it makes the module a bit slower.
 *
 * This function hides the body & teaser, and if requested on that node
 * we hide the title as well.
 *
 * @param[in,out] $node  The affected node.
 */
function protected_node_protected_node_hide(&$node) {
  // Core module fields
  if (!$node->protected_node_show_title) {
    $node->title = t('Password protected page');
  }
  $node->teaser = '';
  $node->body = '';
  $node->content = array();
}


/**
 * Implementation of hook_file_download().
 * @link http://api.drupal.org/api/function/hook_file_download/6
 */
function protected_node_file_download($file) {
  global $user;

  $db_file = db_result(db_query('SELECT u.nid FROM {files} f, {upload} u, {protected_nodes} pn, {node} n WHERE pn.nid = u.nid AND u.nid = n.nid AND f.filename = \'%s\' AND u.fid = f.fid', $file));
  // TODO: $db_file is compared to $user->uid, but set to u.nid (N and not U)
  if (db_error() || $db_file === FALSE || $user->uid == $db_file || $_SESSION['_protected_node']['passwords'][$db_file] || user_access('bypass password protection')) {
    return array();
  }
  else {
    return -1;
  }
}

/*
 * Helper functions
 */

/**
 * Sets the given node to protected with the provided password.
 * The password cannot be empty.
 *
 * If the node already password protected this method changes the password
 * to the one you provided as $password parameter.
 *
 * @param[in,out] object $node The node to be saved.
 * @return boolean TRUE if the action was successful, FALSE otherwise.
 */
function protected_node_save(&$node) {
  // we first test whether a protected_nodes entry exist so we can use UPDATE
  // or INSERT accordingly (UPDATE does not always properly report working
  // with MySQL.)
  $result = db_result(db_query("SELECT protected_node_passwd FROM {protected_nodes} WHERE nid = %d", $node->nid));
  if ($result) {
    // note: the following test prevents the user from using "0"
    //       as a password.
    if (isset($node->protected_node_passwd)) {
      $changed = $node->protected_node_passwd != $result;
      if (empty($node->protected_node_passwd)) {
        // keep result if it's empty...
        $node->protected_node_passwd = $result;
        $changed = FALSE;
      }
      else {
        $node->protected_node_clear_passwd = $node->protected_node_passwd;
        $node->protected_node_passwd = sha1($node->protected_node_passwd);
      }
    }
    else {
      $changed = FALSE;
      $node->protected_node_passwd = $result;
    }
    $sql = "UPDATE {protected_nodes} SET protected_node_is_protected = %d,"
            . " protected_node_passwd = '%s', protected_node_show_title = %d";
    $args = array(
      $node->protected_node_is_protected,
      $node->protected_node_passwd,
      $node->protected_node_show_title,
    );
    if ($changed) {
      $sql .= ", protected_node_passwd_changed = %d";
      $args[] = time(); // last time the password was changed (i.e. invalidate all existing sessions)
    }
    $sql .= " WHERE nid = %d";
    $args[] = $node->nid;
    db_query($sql, $args);
  }
  else {
    if (!isset($node->protected_node_passwd)) {
      // this happens when the global password is to be used
      $node->protected_node_passwd = '';
    }
    elseif($node->protected_node_passwd) {
      $node->protected_node_clear_passwd = $node->protected_node_passwd;
      $node->protected_node_passwd = sha1($node->protected_node_passwd);
    }
    // we don't need to set the protected_node_passwd_changed since no
    // one has ever entered a password for this node
    $sql = "INSERT INTO {protected_nodes} (protected_node_is_protected,"
            . " protected_node_passwd, protected_node_show_title, nid)"
            . " VALUES (%d, '%s', %d, %d)";
    db_query($sql, $node->protected_node_is_protected,
                   $node->protected_node_passwd,
                   $node->protected_node_show_title,
                   $node->nid);
  }
}

/**
 * Load the node extension fields.
 *
 * @param[in] int $nid The node id you wish to check for.
 * @return An array with the node extended fields.
 */
function protected_node_load($nid) {
  if (!is_numeric($nid)) {
    return FALSE;
  }

  $sql = "SELECT protected_node_is_protected, protected_node_passwd, protected_node_passwd_changed,"
            . " protected_node_show_title FROM {protected_nodes} WHERE nid = %d";
  $result = db_fetch_array(db_query($sql, $nid));
  if (is_array($result)) {
    $result += array(
      'protected_node_is_protected' => FALSE,
      'protected_node_passwd' => '',
      'protected_node_passwd_changed' => 0,
      'protected_node_show_title' => 0,
    );
  }

  // the password is a CHAR(40) and when empty it's all spaces
  // (this is possible when the global password is to be used)
  $result['protected_node_passwd'] = trim($result['protected_node_passwd']);

  return $result;
}

/**
 * Implementation of hook_token_list().
 *
 * This function defines some extras for the protected node (i.e. whether a
 * node is protected, title flag, last time the password was changed, etc.)
 */
function protected_node_token_list($type = 'all') {
  if ($type == 'node' || $type == 'all') {
    $tokens['node']['node-is-protected']        = t('Whether the node is protected (yes/no).');
    $tokens['node']['node-password']            = t('The password in clear (only if available, empty otherwise).');
    $tokens['node']['node-protected-title']     = t('Whether the title node of the node is protected (yes/no).');
    return $tokens;
  }
}

/**
 * Implementation of hook_token_values().
 */
function protected_node_token_values($type, $object = NULL, $options = array()) {
  if ($type == 'node' && $object) {
    if (empty($object->protected_node_is_protected)) {
      $tokens['node-is-protected'] = t('no');
      $tokens['node-password'] = '';
      $tokens['node-protected-title'] = '';
    }
    else {
      $tokens['node-is-protected'] = t('yes');
      $tokens['node-password'] = empty($object->protected_node_clear_passwd) ? '' : $object->protected_node_clear_passwd;
      $tokens['node-protected-title'] = empty($object->protected_node_show_title) ? t('yes') : t('no');
    }
    return $tokens;
  }
}

/**
 * This method determines the protected flag status for the given node id.
 *
 * @param int $nid The node id you wish to check for.
 * @return boolean TRUE if the node identified by the nid you provided is protected, FALSE otherwise.
 */
function protected_node_isset_protected($nid) {
  if (!is_numeric($nid)) {
    return FALSE;
  }

  return db_result(db_query('SELECT protected_node_is_protected FROM {protected_nodes} WHERE nid = %d', $nid)) == 1;
}

/**
 * After_build function to disable autocomplete for the password fields.
 *
 * Without this FF >= 3 will attempt to autocomplete the fields with the user's login info.
 *
 * @link http://api.drupal.org/api/file/developer/topics/forms_api_reference.html/6#after_build
 */
function protected_node_autocomplete_off($form_element, &$form_state) {
  $form_element['pass1']['#attributes']['autocomplete'] = 'off';
  $form_element['pass2']['#attributes']['autocomplete'] = 'off';

  return $form_element;
}

/**
 * Implementation of hook_db_rewrite_sql().
 *
 * This hook forbids end users from seeing a node they do not otherwise have
 * access to without a password.
 */
function protected_node_db_rewrite_sql($query, $primary_table, $primary_field, $args) {
  if ($primary_field != 'nid') {
    return;
  }
  if (user_access('access protected content')) {
    return;
  }

  // Prevent query from finding nodes the current user may not have permission to see.
  // (i.e. if the user doesn't know the password, then it shouldn't be shown)
  $join = "LEFT JOIN {protected_nodes} protected_nd ON $primary_table.nid = protected_nd.nid";
  $where = "protected_nd.nid IS NULL";

  return array('join' => $join, 'where' => $where);
}

/**
 * Prevent boost from caching protected nodes.
 *
 * @todo
 * We also need to make sure the cache gets cleared whenever
 * the protection is turned on.
 */
function protected_node_boost_is_cacheable($path) {
  // the $path may be an alias, unalias first
  $url = drupal_lookup_path('source', $path);
  if (!$url) {
    // $path is not an alias, use $path as is for our test
    $url = $path;
  }
  $p = explode('/', $url);
  if (count($p) == 2 && $p[0] == 'node' && is_numeric($p[1])) {
    // if protected, do not cache (i.e. not caching == return FALSE)
    return !protected_node_isset_protected($p[1]);
  }
}

// vim: ts=2 sw=2 et syntax=php
